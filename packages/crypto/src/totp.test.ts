import { describe, it, expect } from 'vitest';
import {
  deriveTotpEncryptionKey,
  encryptTotpSecret,
  decryptTotpSecret,
  generateTotpSecret,
  generateTotpUri,
  verifyTotpCode,
  generateTotpCodeSync,
} from './totp.js';

const TEST_MASTER_SECRET = new Uint8Array(32).fill(1);

describe('totp', () => {
  describe('deriveTotpEncryptionKey', () => {
    it('derives a 32-byte encryption key', () => {
      const key = deriveTotpEncryptionKey(TEST_MASTER_SECRET);

      expect(key).toBeInstanceOf(Uint8Array);
      expect(key.length).toBe(32);
    });

    it('produces consistent key for same master secret', () => {
      const key1 = deriveTotpEncryptionKey(TEST_MASTER_SECRET);
      const key2 = deriveTotpEncryptionKey(TEST_MASTER_SECRET);

      expect(key1).toEqual(key2);
    });

    it('produces different keys for different master secrets', () => {
      const secret2 = new Uint8Array(32).fill(2);
      const key1 = deriveTotpEncryptionKey(TEST_MASTER_SECRET);
      const key2 = deriveTotpEncryptionKey(secret2);

      expect(key1).not.toEqual(key2);
    });
  });

  describe('generateTotpSecret', () => {
    it('returns a base32 encoded string', () => {
      const secret = generateTotpSecret();

      expect(typeof secret).toBe('string');
      expect(secret.length).toBeGreaterThan(0);
      // Base32 characters only
      expect(secret).toMatch(/^[A-Z2-7]+$/);
    });

    it('generates unique secrets', () => {
      const secret1 = generateTotpSecret();
      const secret2 = generateTotpSecret();

      expect(secret1).not.toBe(secret2);
    });
  });

  describe('encryptTotpSecret / decryptTotpSecret', () => {
    it('encrypts and decrypts a secret correctly', () => {
      const originalSecret = generateTotpSecret();
      const encryptionKey = deriveTotpEncryptionKey(TEST_MASTER_SECRET);

      const blob = encryptTotpSecret(originalSecret, encryptionKey);
      const decrypted = decryptTotpSecret(blob, encryptionKey);

      expect(decrypted).toBe(originalSecret);
    });

    it('returns a Uint8Array blob', () => {
      const secret = generateTotpSecret();
      const encryptionKey = deriveTotpEncryptionKey(TEST_MASTER_SECRET);

      const blob = encryptTotpSecret(secret, encryptionKey);

      expect(blob).toBeInstanceOf(Uint8Array);
    });

    it('produces different ciphertext for same input (random nonce)', () => {
      const secret = generateTotpSecret();
      const encryptionKey = deriveTotpEncryptionKey(TEST_MASTER_SECRET);

      const blob1 = encryptTotpSecret(secret, encryptionKey);
      const blob2 = encryptTotpSecret(secret, encryptionKey);

      expect(blob1).not.toEqual(blob2);
    });

    it('throws when decrypting with wrong key', () => {
      const secret = generateTotpSecret();
      const encryptionKey = deriveTotpEncryptionKey(TEST_MASTER_SECRET);
      const wrongKey = deriveTotpEncryptionKey(new Uint8Array(32).fill(2));
      const blob = encryptTotpSecret(secret, encryptionKey);

      expect(() => decryptTotpSecret(blob, wrongKey)).toThrow();
    });
  });

  describe('generateTotpUri', () => {
    it('generates valid otpauth URI', () => {
      const secret = generateTotpSecret();
      const accountLabel = 'user@example.com';

      const uri = generateTotpUri(accountLabel, secret);

      expect(uri).toContain('otpauth://totp/');
      expect(uri).toContain('HushBox');
      expect(uri).toContain(encodeURIComponent(accountLabel));
      expect(uri).toContain(`secret=${secret}`);
    });

    it('encodes special characters in account label', () => {
      const secret = generateTotpSecret();
      const accountLabel = 'user+test@example.com';

      const uri = generateTotpUri(accountLabel, secret);

      expect(uri).toContain(encodeURIComponent(accountLabel));
    });
  });

  describe('verifyTotpCode', () => {
    it('returns false for invalid code format', async () => {
      const secret = generateTotpSecret();

      expect(await verifyTotpCode('invalid', secret)).toBe(false);
      expect(await verifyTotpCode('12345', secret)).toBe(false);
      expect(await verifyTotpCode('1234567', secret)).toBe(false);
    });

    it('returns false for wrong code', async () => {
      const secret = generateTotpSecret();

      // Very unlikely to be the current valid code
      expect(await verifyTotpCode('000000', secret)).toBe(false);
    });

    it('returns true for a valid code generated by generateTotpCodeSync', async () => {
      const secret = generateTotpSecret();
      const code = generateTotpCodeSync(secret);

      expect(await verifyTotpCode(code, secret)).toBe(true);
    });
  });

  describe('generateTotpCodeSync', () => {
    it('returns a 6-digit numeric string', () => {
      const secret = generateTotpSecret();
      const code = generateTotpCodeSync(secret);

      expect(typeof code).toBe('string');
      expect(code).toMatch(/^\d{6}$/);
    });

    it('returns the same code for same secret within the same time window', () => {
      const secret = generateTotpSecret();
      const code1 = generateTotpCodeSync(secret);
      const code2 = generateTotpCodeSync(secret);

      expect(code1).toBe(code2);
    });

    it('returns different codes for different secrets', () => {
      const secret1 = generateTotpSecret();
      const secret2 = generateTotpSecret();
      const code1 = generateTotpCodeSync(secret1);
      const code2 = generateTotpCodeSync(secret2);

      // Different secrets should produce different codes (extremely high probability)
      expect(code1).not.toBe(code2);
    });
  });
});
